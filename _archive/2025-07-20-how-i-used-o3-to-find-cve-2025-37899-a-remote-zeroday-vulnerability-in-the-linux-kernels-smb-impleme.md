---
title: "How I used o3 to find CVE-2025-37899, a remote zeroday vulnerability in the Linux kernel’s SMB implementation – Sean Heelan's Blog"
tags:
   - CVE-2025-37899
   - OpenAI o3
   - security auditing
   - Linux kernel
   - vulnerability research
link: https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/
date: 2025-07-20
description: "Using OpenAI's O3 model, the author discovered CVE-2025-37899, a remote zero-day vulnerability in the Linux kernel’s SMB implementation, showcasing significant advancements in LLM capabilities for vulnerability research. O3 identified a use-after-free condition in concurrent connection handling, marking a breakthrough in LLM-assisted vulnerability detection. Benchmarks indicate O3 performs 2-3x better than previous models, achieving insights in complex code structures with reduced false-positive rates. As LLMs evolve, they may enhance human vulnerability researchers' efficiency, but caution is warranted regarding overreliance due to potential inaccuracies."
---
{% raw %}

[Skip to content](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/#content)

Search for:Close

X Follow Button

In this post I’ll show you how I found a zeroday vulnerability in the Linux kernel using OpenAI’s o3 model. I found the vulnerability with nothing more complicated than the o3 API – no scaffolding, no agentic frameworks, no tool use.

Recently I’ve been auditing ksmbd for vulnerabilities. ksmbd is “ _[a linux kernel server which implements SMB3 protocol in kernel space for sharing files over network.](https://www.kernel.org/doc/html/v6.6/filesystems/smb/ksmbd.html)_“. I started this project specifically to take a break from LLM-related tool development but after the release of o3 I couldn’t resist using the bugs I had found in ksmbd as a quick benchmark of o3’s capabilities. In a future post I’ll discuss o3’s performance across all of those bugs, but here we’ll focus on how o3 found a zeroday vulnerability during my benchmarking. The vulnerability it found is CVE-2025-37899 (fix [here](https://github.com/torvalds/linux/commit/2fc9feff45d92a92cd5f96487655d5be23fb7e2b)), a use-after-free in the handler for the SMB ‘logoff’ command. Understanding the vulnerability requires reasoning about concurrent connections to the server, and how they may share various objects in specific circumstances. o3 was able to comprehend this and spot a location where a particular object that is not referenced counted is freed while still being accessible by another thread. As far as I’m aware, this is the first public discussion of a vulnerability of that nature being found by a LLM.

Before I get into the technical details, the main takeaway from this post is this: with o3 LLMs have made a leap forward in their ability to reason about code, and if you work in vulnerability research you should start paying close attention. If you’re an expert-level vulnerability researcher or exploit developer the machines aren’t about to replace you. In fact, it is quite the opposite: they are now at a stage where they can make you _significantly_ more efficient and effective. If you have a problem that can be represented in fewer than 10k lines of code there is a reasonable chance o3 can either solve it, or help you solve it.

## Benchmarking o3 using CVE-2025-37778

Lets first discuss CVE-2025-37778, a vulnerability that I found manually and which I was using as a benchmark for o3’s capabilities when it found the zeroday, CVE-2025-37899.

CVE-2025-37778 is a use-after-free vulnerability. The issue occurs during the Kerberos authentication path when handling a “ _session setup_” request from a remote client. To save us referring to CVE numbers, I will refer to this vulnerability as the “ _kerberos authentication vulnerability_“.

The root cause looks as follows:

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15 | `static` `int` `krb5_authenticate(` `struct` `ksmbd_work *work,`<br>`                 ``struct` `smb2_sess_setup_req *req,`<br>`                 ``struct` `smb2_sess_setup_rsp *rsp)`<br>`{`<br>`...`<br>`    ``if` `(sess->state == SMB2_SESSION_VALID) `<br>`        ``ksmbd_free_user(sess->user);`<br>`    `<br>`    ``retval = ksmbd_krb5_authenticate(sess, in_blob, in_len,`<br>`                     ``out_blob, &out_len);`<br>`    ``if` `(retval) {`<br>`        ``ksmbd_debug(SMB, ` `"krb5 authentication failed\n"` `);`<br>`        ``return` `-EINVAL;`<br>`    ``}`<br>`...` |

If `krb5_authenticate` detects that the session state is `SMB2_SESSION_VALID` then it frees `sess->user`. The assumption here appears to be that afterwards either `ksmbd_krb5_authenticate` will reinitialise it to a new valid value, or that after returning from `krb5_authenticate` with a return value of `-EINVAL` that `sess->user` will not be used elsewhere. As it turns out, this assumption is false. We can force `ksmbd_krb5_authenticate` to not reinitialise `sess->user`, and we can access `sess->user` even if `krb5_authenticate` returns `-EINVAL`.

This vulnerability is a nice benchmark for LLM capabilities as:

1. It is interesting by virtue of being part of the remote attack surface of the Linux kernel.
2. It is not trivial as it requires:
   - (a) Figuring out how to get `sess->state == SMB2_SESSION_VALID` in order to trigger the free.
   - (b) Realising that there are paths in `ksmbd_krb5_authenticate` that do not reinitialise sess->user and reasoning about how to trigger those paths.
   - (c) Realising that there are other parts of the codebase that could potentially access `sess->user` after it has been freed.
3. While it is not trivial, it is also not insanely complicated. I could walk a colleague through the entire code-path in 10 minutes, and you don’t really need to understand a lot of auxiliary information about the Linux kernel, the SMB protocol, or the remainder of ksmbd, outside of connection handling and session setup code. I calculated how much code you would need to read at a minimum if you read every ksmbd function called along the path from a packet arriving to the ksmbd module to the vulnerability being triggered, and it works out at about 3.3k LoC.

OK, so we have the vulnerability we want to use for evaluation, now what code do we show the LLM to see if it can find it? My goal here is to evaluate how o3 would perform were it the backend for a hypothetical vulnerability detection system, so we need to ensure we have clarity on how such a system would generate queries to the LLM. In other words, it is no good arbitrary selecting functions to give to the LLM to look at if we can’t clearly describe how an automated system would select those functions. The _ideal_ use of an LLM is we give it all the code from a repository, it ingests it and spits out results. However, due to context window limitations and regressions in performance that occur as the amount of context increases, this isn’t practically possible right now.

Instead, I thought one possible way that an automated tool could generate context for the LLM was through expansion of each SMB command handler individually. So, I gave the LLM the code for the ‘session setup’ command handler, including the code for all functions it calls, and so on, up to a call depth of 3 (this being the depth required to include all of the code necessary to reason about the vulnerability). I also include all of the code for the functions that read data off the wire, parses an incoming request, selects the command handler to run, and then tears down the connection after the handler has completed. Without this the LLM would have to guess at how various data structures were set up and that would lead to more false positives. In the end, this comes out at about 3.3k LoC (~27k tokens), and gives us a benchmark we can use to contrast o3 with prior models. If you’re interested, the code to be analysed is [here](https://github.com/SeanHeelan/o3_finds_cve-2025-37899/blob/master/session_setup_code.prompt) as a single file, created with the [files-to-prompt](https://github.com/simonw/files-to-prompt) tool.

The final decision is what prompt to use. You can find the system prompt and the other information I provided to the LLM in the .prompt files in [this](https://github.com/SeanHeelan/o3_finds_cve-2025-37899) Github repository. The main points to note are:

1. I told the LLM to look for use-after-free vulnerabilities.
2. I gave it a brief, high level overview of what ksmbd is, its architecture, and what its threat model is.
3. I tried to strongly guide it to not report false positives, and to favour not reporting any bugs over reporting false positives. I have no idea if this helps, but I’d like it to help, so here we are. In fact my entire system prompt is speculative in that I haven’t ran a sufficient number of evaluations to determine if it helps or hinders, so consider it equivalent to me saying a prayer, rather than anything resembling science or engineering. Once I have ran those evaluations I’ll let you know.

To run the query I then use the `llm` tool ( [github](https://github.com/simonw/llm)) like:

```
$ llm --sf system_prompt_uafs.prompt                \
        -f session_setup_code.prompt                \
        -f ksmbd_explainer.prompt                   \
        -f session_setup_context_explainer.prompt   \
        -f audit_request.prompt
```

My experiment harness executes this N times (N=100 for this particular experiment) and saves the results. It’s worth noting, if you rerun this you may not get _identical_ results to me as between running the original experiment and writing this blog post I had removed the [file](https://github.com/SeanHeelan/o3_finds_cve-2025-37899/blob/master/session_setup_code.prompt) containing the code to be analysed, and had to regenerate it. I believe it is effectively identical, but have not re-run the experiment.

o3 finds the kerberos authentication vulnerability in the benchmark in 8 of the 100 runs. In another 66 of the runs o3 concludes there is no bug present in the code (false negatives), and the remaining 28 reports are false positives. For comparison, Claude Sonnet 3.7 finds it 3 out of 100 runs and Claude Sonnet 3.5 does not find it in 100 runs.So on this benchmark at least we have a 2x-3x improvement in o3 over Claude Sonnet 3.7.

For the curious, I have uploaded a sample report from o3 ( [here](https://github.com/SeanHeelan/o3_finds_cve-2025-37899/blob/master/o3_finds_CVE-2025-37778.txt)) and Sonnet 3.7 ( [here](https://github.com/SeanHeelan/o3_finds_cve-2025-37899/blob/master/claude_3_7_finds_CVE-2025-37778.txt)). One aspect I found interesting is their presentation of results. With o3 you get something that feels like a human-written bug report, condensed to just present the findings, whereas with Sonnet 3.7 you get something like a stream of thought, or a work log. There are pros and cons to both. o3’s output is typically easier to follow due to its structure and focus. On the other hand, sometimes it is too brief, and clarity suffers.

## o3 finds a 0-day (CVE-2025-37899)

Having confirmed that o3 can find the kerberos authentication vulnerability (CVE-2025-37778) when given the code for the session setup command handler, I wanted to see if it could find it if I give it the code for **all** of the command handlers. This is a harder problem as the command handlers are all found in [smb2pdu.c](https://github.com/torvalds/linux/blob/master/fs/smb/server/smb2pdu.c), which has ~9k LoC. However, if o3 can still find vulnerabilities when given all of the handlers in one go then it suggests we can build a more straightforward wrapper for o3 that simply hands it entire files, covering a variety of functionality, rather than going handler by handler.

Combining the code for all of the handlers with the connection setup and teardown code, as well as the command handler dispatch routines, ends up at about 12k LoC (~100k input tokens), and as before I ran the experiment 100 times.

o3 finds the kerberos authentication vulnerability in 1 out of 100 runs with this larger number of input tokens, so a clear drop in performance, but it does still find it. More interestingly however, in the output from the other runs I found a report for a similar, but novel, vulnerability that I did not previously know about. This vulnerability is also due to a free of `sess->user`, but this time in the session logoff handler.

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21 | `int` `smb2_session_logoff(` `struct` `ksmbd_work *work)`<br>`{`<br>`    ``struct` `ksmbd_conn *conn = work->conn;`<br>`    ``struct` `ksmbd_session *sess = work->sess;`<br>`    `<br>`    ``...`<br>`    `<br>`    ``ksmbd_close_session_fds(work);`<br>`    ``ksmbd_conn_wait_idle(conn);`<br>`    `<br>`    ``...`<br>`    `<br>`    ``down_write(&conn->session_lock);`<br>`    ``sess->state = SMB2_SESSION_EXPIRED;`<br>`    ``up_write(&conn->session_lock);`<br>`    ``if` `(sess->user) {`<br>`        ``ksmbd_free_user(sess->user);`<br>`        ``sess->user = NULL;`<br>`    ``}`<br>`    ``...` |

I’ll let o3 explain the issue:

````
Short description
=================
While one ksmbd worker thread is still executing requests that use
sess‑>user, another thread that processes an SMB2 LOGOFF for the same
session frees that structure.  No synchronisation protects the pointer,
so the first thread dereferences freed memory – a classic
use‑after‑free that leads to kernel memory corruption and arbitrary code
execution in kernel context.

Affected code path
------------------
1.  A second transport is bound to an existing session
    (SMB 3.0 or later, `conn->binding == true`).

2.  Worker‑A (running on connection C2) receives any normal request
    (e.g. WRITE).
       • `smb2_check_user_session()` stores a pointer to the already
         existing `struct ksmbd_session` in `work->sess` and
         increments the session ref‑count, **but it does not take
         any reference on `sess->user`.**
       • The pointer to `sess` is kept for the whole request
         processing; every helper that needs authentication data
         accesses `sess->user` directly.

3.  Before Worker‑A finishes, Worker‑B (running on the first connection
    C1) processes an SMB2 ​LOGOFF for the same session and executes
    `smb2_session_logoff()` (smb2pdu.c).

Relevant part of smb2_session_logoff()
--------------------------------------

```c
	...
	if (sess->user) {
		ksmbd_free_user(sess->user);   /* (1) frees memory     */
		sess->user = NULL;             /* (2) clear the field  */
	}
	...
```

`ksmbd_free_user()` ultimately ends in simple `kfree(user)`.

4.  Worker‑B **does not wait for the other connections that are still
    using the session**; it only waits for running requests on *its own*
    connection (`ksmbd_conn_wait_idle(conn)`).

5.  Worker‑A continues to execute (e.g. inside `smb2_open()`,
   `smb2_write()`, …) and dereferences `sess->user`:

```c
/* examples (many of them) */
if (user_guest(sess->user))        ← dereference after free
ksmbd_compare_user(sess->user, …)
sess->user->uid
```

Because the memory was already `kfree()`‑ed in step (1) the access is to
freed memory.  Depending on exact timing it is either:

• a use‑after‑free (pointer still points into now‑reused slab object),
  enabling controlled kernel‑memory overwrite, or
• a NULL–deref (if Worker‑A reads after step (2)), still a DoS.
````

Reading this report I felt my expectations shift on how helpful AI tools are going to be in vulnerability research. If we were to never progress beyond what o3 can do right now, it would still make sense for everyone working in VR to figure out what parts of their work-flow will benefit from it, and to build the tooling to wire it in. Of course, part of that wiring will be figuring out how to deal with the the signal to noise ratio of ~1:50 in this case, but that’s something we are already making progress at.

One other interesting point of note is that when I found the kerberos authentication vulnerability the fix I proposed was as follows:

|     |     |
| --- | --- |
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18 | `diff --git a/fs/smb/server/smb2pdu.c b/fs/smb/server/smb2pdu.c`<br>`index d24d95d15d87..57839f9708bb 100644`<br>`--- a/fs/smb/server/smb2pdu.c`<br>`+++ b/fs/smb/server/smb2pdu.c`<br>`@@ -1602,8 +1602,10 @@ static int krb5_authenticate(struct ksmbd_work *work,`<br>`    ``if (prev_sess_id && prev_sess_id != sess->id)`<br>`        ``destroy_previous_session(conn, sess->user, prev_sess_id);`<br>` `<br>`-   if (sess->state == SMB2_SESSION_VALID)`<br>`+   if (sess->state == SMB2_SESSION_VALID) {`<br>`        ``ksmbd_free_user(sess->user);`<br>`+       sess->user = NULL;`<br>`+   }`<br>` `<br>`    ``retval = ksmbd_krb5_authenticate(sess, in_blob, in_len,`<br>`                     ``out_blob, &out_len);`<br>`-- `<br>`2.43.0` |

When I read o3’s bug report above I realised this was insufficient. The logoff handler _already_ sets `sess->user = NULL`, but is still vulnerable as the SMB protocol allows two different connections to “bind” to the same session and there is nothing on the kerberos authentication path to prevent another thread making use of `sess->user` in the short window after it has been freed and before it has been set to NULL. I had already made use of this property to hit a prior vulnerability in ksmbd but I didn’t think of it when considering the kerberos authentication vulnerability.

Having realised this, I went again through o3’s results from searching for the kerberos authentication vulnerability and noticed that in some of its reports it had made the same error as me, in others it had not, and it had realised that setting `sess->user = NULL` was insufficient to fix the issue due to the possibilities offered by session binding. That is quite cool as it means that had I used o3 to find and fix the original vulnerability I would have, in theory, done a better job than without it. I say ‘in theory’ because right now the false positive to true positive ratio is probably too high to definitely say I would have gone through each report from o3 with the diligence required to spot its solution. Still, that ratio is only going to get better.

## Conclusion

LLMs exist at a point in the capability space of program analysis techniques that is far closer to humans than anything else we have seen. Considering the attributes of creativity, flexibility, and generality, LLMs are far more similar to a human code auditor than they are to symbolic execution, abstract interpretation or fuzzing. Since GPT-4 there has been hints of the potential for LLMs in vulnerability research, but the results on real problems have never quite lived up to the hope or the hype. That has changed with o3, and we have a model that can do well enough at code reasoning, Q&A, programming and problem solving that it can genuinely enhance human performance at vulnerability research.

o3 is not infallible. Far from it. There’s still a substantial chance it will generate nonsensical results and frustrate you. What is different, is that for the first time the chance of getting correct results is sufficiently high that it is worth your time and and your effort to try to use it on real problems.

### Share this:

- [Facebook](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/?share=facebook&nb=1)
- [X](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/?share=x&nb=1)

LikeLoading...

### _Related_

[Game Over! Thank you for playing Academia](https://sean.heelan.io/2009/09/06/game-over-thank-you-for-playing-academia/ "Game Over! Thank you for playing&nbsp;Academia")September 6, 2009In "Exploit generation"

[ISSA Ireland seminar](https://sean.heelan.io/2009/05/06/issa-ireland-seminar/ "ISSA Ireland seminar")May 6, 2009In "Exploitation"

[Automatic exploit generation: Lessons learned so far](https://sean.heelan.io/2009/07/05/automatic-exploit-generation-lessons-learned-so-far/ "Automatic exploit generation: Lessons learned so&nbsp;far")July 5, 2009In "Exploit generation"

## 11 thoughts on “How I used o3 to find CVE-2025-37899, a remote zeroday vulnerability in the Linux kernel’s SMB implementation”

1. Have you tried OpenAI Codex? I tried this with the recently discovered virtualbox escape and found a bug that way.



   - Not yet. I assumed it was tuned towards code editing/writing and hadn’t thought to use it for bug hunting.
2. The link to the sonnet 3.7 result doesn’t work as it doesn’t have the cve number in it



   - Fixed. Thanks!
3. What was the compute cost to perform the analysis?



   - The 100 runs of the ~100k token version cost about $116.
4. Super interesting research! Q1: Have you considered testing Gemini 2.5 Pro Preview model (leads WebDev Arena on LM Arena) or also its Deep Think version? Q2: What other models you may consider. Q3: Thoughts on Sonnet thinking mode? And Sonnet 4 is out and leads coding agent benchmarks, said to outperform Sonnet 3.7 and other models.



   - I haven’t tested Gemini 2.5 Pro yet, but I’m working on some new experiments and I’ll be sure to include it. I’m also planning to include the latest Sonnet and Opus models.
5. I’ve been debating whether or not to comment on this blog.







On the one hand, I find the novel usage of LLMs interesting and it’s quite cool that you found a zero day using this technique.







However, some of the statements in the blog concern me for the overarching theme of usage of LLMs in the security space.







Namely:



_Understanding the vulnerability requires reasoning about concurrent connections to the server, and how they may share various objects in specific circumstances. o3 was able to comprehend this and spot a location where a particular object that is not referenced counted is freed while still being accessible by another thread. As far as I’m aware, this is the first public discussion of a vulnerability of that nature being found by a LLM._



_Before I get into the technical details, the main takeaway from this post is this: with o3 LLMs have made a leap forward in their ability to reason about code, and if you work in vulnerability research you should start paying close attention._







Maybe you’ll see this as pedantic but LLMs understand nothing and do not reason. It has no thoughts about objects in various circumstances, it has no ability to “reason” code as it cannot think. And the reason why I want to emphasize this is because it’s also not surprising that the CVE it discovered (technically, you discovered while reviewing the false positives of the LLM’s response to a test dataset because there were 28 false positives in the same space) is semantically related to the CVE you were originally using to try and test its ability to identify vulnerabilities.



I want to emphasize this because I find it reckless if people in the security space continuously believe that LLMs actually reason code or have any kind of understanding about how code operates, no matter how much LLMs may appear to understand code or “know” how to code, it understands nothing about code but rather just predicting sequences of characters that follow each other. If individuals start relying on an LLM to actually “analyze” code semantics and behaviors, we’re going to be having a bad time and the way the entire security space is going, it seems like people aren’t grasping this exceptionally important limitation of LLMs.



   - Hey Ryan,



     Nothing wrong with a bit of pedantry 😉



     I think there are two aspects to this topic:



     (1) The largely philosophical discussion around what is reasoning and whether LLMs do it, or what is consciousness and whether LLMs can have it. I have put next to no thought into this as for me all I care about is “Can I build useful things with this tool”. So, in the post when I use the words “reasoning” and “comprehension” I am not asserting human-like attributes. Feel free to replace “o3 was able to comprehend this” with “o3 was able to solve this”, as it’s the same claim I’d make about a symbolic execution engine or a fuzzer that could solve a similar problem.



     (2) The practical discussion about whether or not we can build useful tools on top of LLMs that require code analysis. On this, I think it is more likely than not that LLMs will end up being a relatively effective solution to things like bug finding, and find their way into the toolbox of engineers alongside traditional static analysis and fuzzing. Obviously you need some sort of mechanism to verify solutions, but if you have one then it doesn’t matter if the LLM generates 99% nonsense as you can filter it out. Again, here you don’t need to believe LLMs are reasoning or comprehending anything. To be honest I even find that to be a hindrance, and it’s more effective to consider them like fuzzing where you are sampling from a distribution.



     I hope that clears up some things.



     - Yea that clears things up. I agree that LLMs will find their place in bug finding, I just would hate to see it go down the route of Threat Detection where everyone is trying to have LLMs perform all analysis and thought away from the security field which is horrendously irresponsible in my opinion.

Comments are closed.

[_Back to top_](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/#top)

- [Reblog](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/)
- [Subscribe](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/) [Subscribed](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/)








- [![](https://sean.heelan.io/wp-content/uploads/2009/05/cropped-oxford_7602.jpg?w=50) Sean Heelan's Blog](https://sean.heelan.io/)

Join 44 other subscribers

Sign me up

- Already have a WordPress.com account? [Log in now.](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fsean.heelan.io%252F2025%252F05%252F22%252Fhow-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation%252F)


- - [![](https://sean.heelan.io/wp-content/uploads/2009/05/cropped-oxford_7602.jpg?w=50) Sean Heelan's Blog](https://sean.heelan.io/)
- [Subscribe](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/) [Subscribed](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/)
- [Sign up](https://wordpress.com/start/)
- [Log in](https://wordpress.com/log-in?redirect_to=https%3A%2F%2Fr-login.wordpress.com%2Fremote-login.php%3Faction%3Dlink%26back%3Dhttps%253A%252F%252Fsean.heelan.io%252F2025%252F05%252F22%252Fhow-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation%252F)
- [Copy shortlink](https://wp.me/pw5Z4-Mh)
- [Report this content](https://wordpress.com/abuse/?report_url=https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/)
- [View post in Reader](https://wordpress.com/reader/blogs/7649502/posts/2993)
- [Manage subscriptions](https://subscribe.wordpress.com/)
- [Collapse this bar](https://sean.heelan.io/2025/05/22/how-i-used-o3-to-find-cve-2025-37899-a-remote-zeroday-vulnerability-in-the-linux-kernels-smb-implementation/)

%d

Twitter Widget Iframe
{% endraw %}
